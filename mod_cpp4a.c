/* 
**  mod_cpp4a.c -- Apache sample cpp4a module
**  [Autogenerated via ``apxs -n cpp4a -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_cpp4a.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /cpp4a in as follows:
**
**    #   httpd.conf
**    LoadModule cpp4a_module modules/mod_cpp4a.so
**    <Location /cpp4a>
**    SetHandler cpp4a
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /cpp4a and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/cpp4a 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_cpp4a.c
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "apr_pools.h"
#include "apr_file_io.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dlfcn.h>


//global compile command name in config file
#define CPP4A_CC "CC"
#define CPP4A_DEGUG


char* trim(char *str);
int strIsEmpty(char *str);
int readConf(char *cmdName,char *cmdValue,char *cmdLine,int *cmdLineLen,int *isFoundCmd,request_rec *r);
typedef struct {
    int         enabled;      /* Enable or disable our module */
    const char *conf;         /* Configurate file path */
} cpp4a_config;

static cpp4a_config config;

/* Handler for the "cpp4aEnabled" directive */
const char *cpp4a_set_enabled(cmd_parms *cmd, void *cfg, const char *arg)
{
    if(!strcasecmp(arg, "on")) config.enabled = 1;
    else config.enabled = 0;
    return NULL;
}

/* Handler for the "examplePath" directive */
const char *cpp4a_set_conf(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.conf = arg;
    return NULL;
}

static const command_rec cpp4a_directives[] =
{
    AP_INIT_TAKE1("cpp4aEnabled", cpp4a_set_enabled, NULL, RSRC_CONF, "Enable or disable mod_example"),
    AP_INIT_TAKE1("cpp4aConf", cpp4a_set_conf, NULL, RSRC_CONF, "The configure file"),
    { NULL }
};

/* The sample content handler */
static int cpp4a_handler(request_rec *r)
{
    if (strcmp(r->handler, "cpp4a")) {
        return DECLINED;
    }
    r->content_type = "text/html";
    if(access(r->filename,F_OK)==-1){
			return HTTP_NOT_FOUND;
    }else if(access(r->filename,R_OK)==-1){
			return HTTP_FORBIDDEN;
    }
    
    	apr_finfo_t finfo;
	int rc,exists;
	//char filename[256]={0};
	char dirBin[]=".bin/";
	int dirBinLen=strlen(dirBin);
	
	char fileCmd[]=".cmd";
	int fileCmdLen=strlen(fileCmd);
	
	char suffixCh[]=".ch";
	int suffixChLen=strlen(suffixCh); //".ch" length
	
	char suffixSo[]=".so";
	int suffixSoLen=strlen(suffixSo); //".so" length
	
	char *nameNoSuf=NULL; // eg: "index"
	int nameNoSufLen=0; // the length of "index"(5)
	
	char *basePath=NULL; //eg: "/home/tarena/program/apache/htdocs/"
	int basePathLen=0; // the length of basePath
	
	char *binBasePath=NULL; //eg: "/home/tarena/program/apache/htdocs/.bin/"
	int binBasePathLen=basePathLen+dirBinLen ;// .bin/
	
	char *binFullPath=NULL; //eg: "/home/tarena/program/apache/htdocs/.bin/index.so"
	int binFullPathLen=binBasePathLen+nameNoSufLen+suffixSoLen; 
	
	char *cmdPath=NULL; //eg: "/home/tarena/program/apache/htdocs/.cmd"
	int cmdPathLen=basePathLen+fileCmdLen ;//.cmd

    nameNoSufLen=strlen(r->filename)-((int)(rindex(r->filename,'/')-r->filename)+1)-suffixChLen;
    basePathLen=strlen(r->filename)-nameNoSufLen-suffixChLen;
    binBasePathLen=basePathLen+5 ;
    binFullPathLen=binBasePathLen+nameNoSufLen+suffixSoLen;
    cmdPathLen=basePathLen+4 ;
	
    nameNoSuf=(char*)calloc(nameNoSufLen+1,1);
	if(nameNoSuf==NULL){
#ifdef CPP4A_DEGUG
		ap_rprintf(r,"Memory allocation failure:10000001");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
    basePath=(char*)calloc(basePathLen+1,1);
	if(basePath==NULL){
#ifdef CPP4A_DEGUG
		ap_rprintf(r,"Memory allocation failure:10000001");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
    binBasePath=(char*)calloc(binBasePathLen+1,1);
	if(binBasePath==NULL){
#ifdef CPP4A_DEGUG
		ap_rprintf(r,"Memory allocation failure:10000001");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
    binFullPath=(char*)calloc(binFullPathLen+1,1);
	
	if(binFullPath==NULL){
#ifdef CPP4A_DEGUG
		ap_rprintf(r,"Memory allocation failure:10000001");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
    cmdPath=(char*)calloc(cmdPathLen+1,1);
	if(cmdPath==NULL){
#ifdef CPP4A_DEGUG
		ap_rprintf(r,"Memory allocation failure:10000001");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
	
    strncpy(nameNoSuf,r->filename+basePathLen,nameNoSufLen);
	strncpy(basePath,r->filename,basePathLen);

	
	strncpy(binBasePath,basePath,basePathLen);
	strcat(binBasePath,dirBin);

	strncpy(binFullPath,binBasePath,binBasePathLen);
	strcat(binFullPath,nameNoSuf);
	strcat(binFullPath,suffixSo);
	
	strncpy(cmdPath,basePath,basePathLen);
	strcat(cmdPath,fileCmd);
	
    apr_pool_t *apt;
    apr_status_t apst;
    if(access(binBasePath,F_OK)!=0){
		apst=apr_dir_make(binBasePath,0x755,apt);
		if(apst!=0){
#ifdef CPP4A_DEGUG
			ap_rprintf(r,"Operation not permitted , %s cannot be create:error code 10000002<br>",binBasePath);
			return OK;
#else	
			return HTTP_INTERNAL_SERVER_ERROR;
#endif
		}
		apr_file_perms_set(binBasePath,0x755);
    }
    //if source file is earier , load the share object file 
	if(access(binFullPath,F_OK)==0){
		struct stat sBuf;
		int sRst=0;
		struct stat dBuf;
		int dRst=0;
		sRst=stat(r->filename,&sBuf);
		if(sRst==0){
			dRst=stat(binFullPath,&dBuf);
			if(sBuf.st_mtime<dBuf.st_mtime){
				int rst=loadSharedOb(binFullPath,r);
				if(rst==OK){
					return OK;
				}else if(rst==HTTP_INTERNAL_SERVER_ERROR){
					return HTTP_INTERNAL_SERVER_ERROR;
				}
			}
		}	
	}
    //char cmdLine[512]={0};
    char* cmdLine=(char*)malloc(512);
    int cmdLineLen=sizeof(cmdLine);
    char cmdName[256]={0};
    char cmdValue[256]={0};
    int isFoundCmd=0;
    if(access(cmdPath,R_OK)!=0){
		int rst=readConf(cmdName,cmdValue,cmdLine,&cmdLineLen,&isFoundCmd,r);
    }else{
		FILE *cmdFd=fopen(cmdPath,"r");
		if(cmdFd==NULL){
#ifdef CPP4A_DEGUG
			ap_rprintf(r,"Open %s failure<br>",cmdPath);
			return OK;
#else
			return HTTP_INTERNAL_SERVER_ERROR;
#endif
		}
		while(feof(cmdFd)==0){
			int rst=getline(&cmdLine,&cmdLineLen,cmdFd);
			if(rst>0){
				sscanf(cmdLine,"%[^=]=%[^\n]",cmdName,cmdValue);
				trim(cmdName);
				trim(cmdValue);
				if(strcmp(cmdName,nameNoSuf)==0){
					isFoundCmd=1;
					break;
				}
			}
		}
		fclose(cmdFd);
		if(isFoundCmd==0){
			readConf(cmdName,cmdValue,cmdLine,&cmdLineLen,&isFoundCmd,r);
		}
	}
	if(isFoundCmd==0){
#ifdef CPP4A_CC
		ap_rprintf(r,"compile command cannot be find : error code 10000005");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
	
	strcat(cmdValue," -fpic -shared -o ");
	strcat(cmdValue,binFullPath);
	strcat(cmdValue," ");
	strcat(cmdValue,r->filename);
    int cRst=system(cmdValue);
	if(cRst==0){
		int rst=loadSharedOb(binFullPath,r);
		if(rst==OK){
			return OK;
		}else if(rst==HTTP_INTERNAL_SERVER_ERROR){
			return HTTP_INTERNAL_SERVER_ERROR;
		}
	}else{
#ifdef CPP4A_CC
		ap_rprintf(r,"compile error : error code 10000008<br>");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
	free(cmdLine);
	free(nameNoSuf);
	nameNoSuf=NULL;
	free(basePath);
	basePath=NULL;
	free(binBasePath);
	binBasePath=NULL;
	free(binFullPath);
	binFullPath=NULL;
	free(cmdPath);
	cmdPath=NULL;
    return OK;
}
int loadSharedOb(char *binFullPath,request_rec *r){
	void *handle;
	//char (*run)(request_rec *r);
	char* (*run)();
	handle=dlopen(binFullPath,RTLD_LAZY);
	if(handle==NULL){
#ifdef CPP4A_CC
		ap_rprintf(r,"load shared library %s failure: error 10000006",binFullPath);
		return OK;
#else
	return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
	*(void **) (&run) = dlsym(handle, "run");
	if(run==NULL){
#ifdef CPP4A_CC
		ap_rprintf(r,"No run function : error code 10000007<br>");
		return OK;
#else
		return HTTP_INTERNAL_SERVER_ERROR;
#endif
	}
	//char *rst=(*run)(r);
	char *rst=(*run)();
	ap_rprintf(r,"%s",rst);
	dlclose(handle);
	return OK;
}
int readConf(char *cmdName,char *cmdValue,char *cmdLine,int * cmdLineLen,int *isFoundCmd,request_rec *r){
	FILE* confFd=fopen(config.conf,"r");
	if(confFd==NULL){
#ifdef CPP4A_DEGUG
		ap_rprintf(r,"Open config file %s failure: 10000004<br>",config.conf);
#endif
		return -1;
	}
	while(feof(confFd)==0){
		int rst=getline(&cmdLine,&cmdLineLen,confFd);
		if(rst>0){
			sscanf(cmdLine,"%[^=]=%[^\n]",cmdName,cmdValue);
			trim(cmdName);
			trim(cmdValue);
			if(strcmp(cmdName,CPP4A_CC)==0){
				*isFoundCmd=1;
				break;
			}
		}
	}
	fclose(confFd);
	return OK;
}
static void cpp4a_register_hooks(apr_pool_t *p)
{
	config.enabled = 1;
	config.conf = "/Home/Program/apache/conf/cpp4a.conf";
    ap_hook_handler(cpp4a_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA cpp4a_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    cpp4a_directives,                  /* table of config file commands       */
    cpp4a_register_hooks  /* register hooks                      */
};
/*
 * trim function move first nonesapce character to the first position
 * set '\0' after the last nonespace character
 * return the origin char*
 */
char* trim(char *str){
	int str_len=strlen(str);

	int i=0;
	int flag=1;
	int spaceNum=0;
	for(i=0;i<str_len;i++){
		if(isspace(*(str+i))&&flag==1){
			spaceNum++;
		}else{
			flag=0;
			break;
		}
	}
	if(spaceNum!=0){
		for(i=0;i<str_len;i++){
			*(str+i)=*(str+i+spaceNum);
		}
	}
	str_len-=spaceNum;
	flag=1;
	spaceNum=0;
	for(i=str_len-1;i>=0;i--){
		if(isspace(*(str+i))&&flag==1){
			spaceNum++;
		}else{
			flag=0;
			break;
		}
	}
	if(spaceNum!=0){
		*(str+str_len-spaceNum)='\0';
	}
	return str;
};
int strIsEmpty(char *str){
	if(str==NULL||*str=='\0'){
		return 1;
	}
	return 0;
}
