/* 
**  mod_cpp4a.c -- Apache sample cpp4a module
**  [Autogenerated via ``apxs -n cpp4a -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_cpp4a.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /cpp4a in as follows:
**
**    #   httpd.conf
**    LoadModule cpp4a_module modules/mod_cpp4a.so
**    <Location /cpp4a>
**    SetHandler cpp4a
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /cpp4a and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/cpp4a 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_cpp4a.c
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "apr_pools.h"
#include "apr_file_io.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>


char* trim(char *str);
int strIsEmpty(char *str);
typedef struct {
    int         enabled;      /* Enable or disable our module */
    const char *conf;         /* Configurate file path */
} cpp4a_config;

static cpp4a_config config;

/* Handler for the "cpp4aEnabled" directive */
const char *cpp4a_set_enabled(cmd_parms *cmd, void *cfg, const char *arg)
{
    if(!strcasecmp(arg, "on")) config.enabled = 1;
    else config.enabled = 0;
    return NULL;
}

/* Handler for the "examplePath" directive */
const char *cpp4a_set_conf(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.conf = arg;
    return NULL;
}

static const command_rec cpp4a_directives[] =
{
    AP_INIT_TAKE1("cpp4aEnabled", cpp4a_set_enabled, NULL, RSRC_CONF, "Enable or disable mod_example"),
    AP_INIT_TAKE1("cpp4aConf", cpp4a_set_conf, NULL, RSRC_CONF, "The configure file"),
    { NULL }
};

/* The sample content handler */
static int cpp4a_handler(request_rec *r)
{
	apr_finfo_t finfo;
	int rc,exists;
	//char filename[256]={0};

	int suffixCh=3; //".ch" length
	int suffixSo=3; //".so" length
	char *nameNoSuf=NULL;
	int nameNoSufLen=0;
	char *basePath=NULL;
	int basePathLen=0;
	char *binBasePath=NULL;
	int binBasePathLen=basePath+5 ;// .bin/
	char *binFullPath=NULL;
	int binFullPathLen=binBasePathLen+nameNoSufLen+suffixSo;
	char *cmdPath=NULL;
	int cmdPathLen=basePath+4 ;//.cmd

    if (strcmp(r->handler, "cpp4a")) {
        return DECLINED;
    }
    r->content_type = "text/html";
    if(access(r->filename,F_OK)==-1){
    	return HTTP_NOT_FOUND;
    }else if(access(r->filename,R_OK)==-1){
    	return HTTP_FORBIDDEN;

    }
    nameNoSufLen=strlen(r->filename);
    while(*(r->filename + nameNoSufLen)!='/'){
    	nameNoSufLen--;
    }
    if(*(r->filename + nameNoSufLen)=='/'){
    	nameNoSufLen++;
    }
    nameNoSufLen=strlen(r->filename)-nameNoSufLen-suffixCh;
//    ap_rprintf(r,"%d<br>",nameNoSufLen);



    int rfilenameLen=strlen(r->filename);
    //ap_rprintf(r,"%d<br>",rfilenameLen);
    char* filename=(char*)malloc(rfilenameLen+1);
    if(filename==NULL){
    	//ap_rprintf(r,"Memory allocation failure:10000001");
    	return HTTP_INTERNAL_SERVER_ERROR;
    }
    memset(filename,0,rfilenameLen+1);
    strcpy(filename,r->filename);
    int temp=rfilenameLen-1;
    int suffixLen=0;
    int flag=0;
    while(temp!=0){
    	if(filename[temp]=='/'){
    		filename[temp]='\0';
    		break;
    	}
    	if(filename[temp]!='.'&&flag==0){
    		suffixLen++;
    	}else{
    		flag=1;
    	}
    	temp--;
    }
    int onlyName=rfilenameLen-(temp+1)-1-suffixLen;//temp+1 array index start from 0,-1 remove '/'
    // /home/Program/apache/htdoc/index
    //char sOnlyName[onlyName+1]={0};
    char sOnlyName[255]={0};
    int targetPathLen=(temp+1)+8+onlyName;//2 + 6 ; 2 "so", 6 "/.bin/" /home/Program/apache/htdoc/.bin
    strcpy(sOnlyName,(r->filename)+rfilenameLen-onlyName-suffixLen-1);//index
    char* targetfname=(char*)malloc(targetPathLen+1);
    if(targetfname==NULL){
        ap_rprintf(r,"Memory allocation failure:10000002");
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    memset(targetfname,0,targetPathLen);
    strcpy(targetfname,filename);
    strcat(targetfname,"/.bin/");
    apr_pool_t *apt;
    apr_status_t apst;
    if(access(targetfname,F_OK)==-1){
    	apst=apr_dir_make(targetfname,0x755,apt);
    	if(apst!=0){
			return HTTP_INTERNAL_SERVER_ERROR;
		}
		apr_file_perms_set(targetfname,0x755);
    }
    int cmdFileLen=strlen(filename)+4;//filename's length plus the .cmd length
    char* cmdFile=(char*)malloc(cmdFileLen+1);
    strcpy(cmdFile,filename);
    strcat(cmdFile,"/.cmd");
    /*
    if(access(cmdFile,R_OK)==0){
    	ap_rprintf(r,"Right<br>");
    }
    */
    FILE *cmdFd=fopen(cmdFile,"r");
    if(cmdFd==NULL){
    	return HTTP_INTERNAL_SERVER_ERROR;
    }
    //char line[512]={0};
    char* line=(char*)malloc(512);
    size_t line_len=sizeof(line);
    char cmdName[256]={0};
    char cmdValue[255]={0};
    int isFoundCmd=0;

    while(feof(cmdFd)==0){
    	int rst=getline(&line,&line_len,cmdFd);
    	if(rst>0){
    		sscanf(line,"%[^=]=%[^\n]",cmdName,cmdValue);
    		trim(cmdName);
    		trim(cmdValue);
    		if(strcmp(cmdName,sOnlyName)==0){
    			isFoundCmd=1;
    			break;
    		}
    	}
    }
    if(isFoundCmd==0){
    	FILE* confFd=fopen(config.conf,"r");
    	if(confFd==NULL){
    		return HTTP_INTERNAL_SERVER_ERROR;
    	}
    	while(feof(cmdFd)==0){
    	    int rst=getline(&line,&line_len,cmdFd);
    	    if(rst>0){
    	    	sscanf(line,"%[^=]=%[^\n]",cmdName,cmdValue);
    	    	trim(cmdName);
    	    	trim(cmdValue);
    	    	if(strcmp(cmdName,sOnlyName)==0){
    	    		isFoundCmd=1;
    	    		break;
    	    	}
    	    }
    	}
    	fclose(confFd);
    }
    fclose(cmdFd);
    free(line);
    free(cmdFile);
    free(targetfname);
    free(filename);
    return OK;
}

static void cpp4a_register_hooks(apr_pool_t *p)
{
	config.enabled = 1;
	config.conf = "/Home/Program/apache/conf/cpp4a.conf";
    ap_hook_handler(cpp4a_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA cpp4a_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    cpp4a_directives,                  /* table of config file commands       */
    cpp4a_register_hooks  /* register hooks                      */
};
/*
 * trim function move first nonesapce character to the first position
 * set '\0' after the last nonespace character
 * return the origin char*
 */
char* trim(char *str){
	int str_len=strlen(str);

	int i=0;
	int flag=1;
	int spaceNum=0;
	for(i=0;i<str_len;i++){
		if(isspace(*(str+i))&&flag==1){
			spaceNum++;
		}else{
			flag=0;
			break;
		}
	}
	if(spaceNum!=0){
		for(i=0;i<str_len;i++){
			*(str+i)=*(str+i+spaceNum);
		}
	}
	str_len-=spaceNum;
	flag=1;
	spaceNum=0;
	for(i=str_len-1;i>=0;i--){
		if(isspace(*(str+i))&&flag==1){
			spaceNum++;
		}else{
			flag=0;
			break;
		}
	}
	if(spaceNum!=0){
		*(str+str_len-spaceNum)='\0';
	}
	return str;
};
int strIsEmpty(char *str){
	if(str==NULL||*str=='\0'){
		return 1;
	}
	return 0;
}
